name: ci-tests-autofix-needed

on:
  workflow_run:
    workflows: ["CI Tests"]
    types: [completed]

permissions:
  contents: read
  issues: write
  pull-requests: write

concurrency:
  group: ci-tests-autofix-needed-${{ github.event.workflow_run.id }}
  cancel-in-progress: false

jobs:
  label-pr:
    if: github.event.workflow_run.event == 'pull_request'
    runs-on: ubuntu-latest

    steps:
      - name: Apply labels based on CI result
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const run = context.payload.workflow_run;

            const conclusion = run.conclusion;
            const prs = run.pull_requests || [];

            core.info(`Workflow: ${run.name}`);
            core.info(`Conclusion: ${conclusion}`);
            core.info(`PRs attached: ${prs.map((p) => `#${p.number}`).join(", ") || "none"}`);

            if (!prs.length) {
              core.info("No PRs attached to this workflow_run; skipping.");
              return;
            }

            const requiredLabel = "automerge";
            const autofixLabel = "autofix-needed";
            const ciFailedLabel = "ci-failed";

            async function ensureRepoLabelExists(name, { color, description }) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (error) {
                const status = error?.status;
                if (status !== 404) {
                  throw error;
                }
                try {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name,
                    color,
                    description,
                  });
                  core.info(`Created label '${name}'.`);
                } catch (createError) {
                  const message = String(createError?.message || createError);
                  if (
                    createError?.status === 422 ||
                    message.toLowerCase().includes("already exists")
                  ) {
                    core.info(`Label '${name}' already exists.`);
                    return;
                  }
                  throw createError;
                }
              }
            }

            async function addIssueLabelIfMissing(prNumber, labels, name) {
              if (labels.includes(name)) {
                core.info(`PR #${prNumber}: label '${name}' already present.`);
                return;
              }

              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: [name],
              });
              core.info(`PR #${prNumber}: added label '${name}'.`);
            }

            async function removeIssueLabelIfPresent(prNumber, labels, name) {
              if (!labels.includes(name)) {
                return;
              }
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: prNumber,
                  name,
                });
                core.info(`PR #${prNumber}: removed label '${name}'.`);
              } catch (error) {
                core.warning(
                  `PR #${prNumber}: failed to remove label '${name}': ${String(
                    error?.message || error
                  )}`
                );
              }
            }

            const failureConclusions = new Set(["failure", "timed_out", "cancelled"]);

            for (const prRef of prs) {
              const prNumber = prRef.number;

              const { data: pr } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });

              if (pr.draft) {
                core.info(`PR #${prNumber}: draft; skipping.`);
                continue;
              }

              if (pr.head?.repo?.full_name !== `${owner}/${repo}`) {
                core.info(`PR #${prNumber}: fork PR; skipping.`);
                continue;
              }

              const labels = (pr.labels || []).map((l) => l.name);

              if (!labels.includes(requiredLabel)) {
                core.info(`PR #${prNumber}: missing label '${requiredLabel}'; skipping.`);
                continue;
              }

              if (conclusion === "success") {
                await removeIssueLabelIfPresent(prNumber, labels, ciFailedLabel);
                core.info(
                  `PR #${prNumber}: CI passed; leaving '${autofixLabel}' unchanged (it may be used by Codex review).`
                );
                continue;
              }

              if (!failureConclusions.has(conclusion)) {
                core.info(
                  `PR #${prNumber}: CI conclusion '${conclusion}' not actionable; skipping.`
                );
                continue;
              }

              await ensureRepoLabelExists(autofixLabel, {
                color: "FBCA04",
                description: "Codex/CI found issues; needs local fixes before automerge.",
              });
              await ensureRepoLabelExists(ciFailedLabel, {
                color: "D73A4A",
                description: "CI Tests failed on this PR.",
              });

              await addIssueLabelIfMissing(prNumber, labels, autofixLabel);
              await addIssueLabelIfMissing(prNumber, labels, ciFailedLabel);
            }

